---
title: "Recovery trajectory of pain in ankle arthritis following non-surgical or surgical treatment: A comparative longitudinal analysis of the SOFARI Registry"
author: "Corey Scholes"
affiliation: "EBM Analytics"
version: 1.0
date: "2025-September-07"
date-modified: "2025-September-07"
type: website
output-dir: docs
editor: visual
code-annotations: true
execute: 
  echo: true
  warning: false
  message: false
format:
  html:
    theme: cosmo
    embed-resources: true
    toc: true
    number-sections: true
    code-fold: true
    
    
bibliography: SOFARI_Followup.bib
---

## Analysis Preamble

The following analysis has been drafted to provided all necessary information to support the findings presented. It represents a collaborative effort drawing on data collected by the SOFARI clinical quality registry.

## Reporting

The study was reported according to the RECORD guidelines [@Benchimol2015] and companion checklist.

The analysis was conducted in RStudio IDE (RStudio 2025.05.0+496 "Mariposa Orchid" Release) using *Rbase*, *quarto* and attached packages to perform the following;

-   Data import and preparation

-   Sample selection

    -   Processing of diagnosis raw text

-   Describe and address missingness

-   Data manipulation, modelling and visualisation of;

    -   Patient characteristics

    -   Pathology characteristics (diagnosis)

    -   Patient reported outcomes
    
    

## Preparation

Load up required packages in advance. Citations are applied to each library at first use in the text. <!--# Reorder these in order of general appearance -->

```{r}
#| label: load-packages

if (!require("pacman")) install.packages("pacman")
pacman::p_load(
  "parameters",
  "fixest",
  "estimatr",
  "ggdag",
  "effectsize",
  "purrr",
  "patchwork",
  "car",
  "corrplot",
  "knitr",
  "cardx",
  "quarto",
  "pROC",
  "reshape",
  "future",
  "furrr",
  "memoise",
  "gargle",
  "googledrive",
  "googlesheets4",
  "openxlsx2",
  "readr",
  "purrr",
  "tidyverse",
  "tidymodels",
  "tidytext",
  "stopwords",
  "tictoc",
  "lubridate",
  "forcats",
  "gt",
  "consort",
  "gtsummary",
  "flextable",
  "survival",
  "ggplot2",
  "ggdist",
  "ggsurvfit",
  "ggfortify",
  "mice",
  "marginaleffects",
  "patchwork",
  "naniar",
  "broom",
  "broom.helpers",
  "labelled",
  "epoxy",
  "janitor",
  "progressr",
  "DT",
  install = TRUE,
  update = FALSE
)

```

```{r}
#| label: tbl-pkgcite
#| echo: false
#| tbl-cap: Summary of package usage and citations

# Generate table
pkgs <- grateful::cite_packages(
  dependencies = FALSE,
  output = "table", 
  out.dir = ".",
  cite.tidyverse = TRUE,
  include.RStudio = FALSE,
  bib.file = "grateful-refs.bib"
)

knitr::kable(pkgs)

```

## Authorisations

Pre-authorise access to registry datasets using the *gargle* package.

```{r}
#| echo: false

# Set the cache location
options(gargle_oauth_cache = ".secrets")

# Use the saved token for non-interactive auth
drive_auth(email = "cscholes@ebma.com.au", 
          cache = ".secrets")
```

```{r}
#| echo: false

options(
  gargle_oauth_cache = ".secrets",
  gargle_oauth_email = TRUE
)

drive_auth(cache = ".secrets", email = TRUE)
```

## Functions for Processing

Include a series of functions to call later in the file for processing data imports.

Function to retrieve files, using the *googledrive* package.

```{r}
#| echo: false

base_folder_id1 <- "1ldAFbv_g6zoF14_zt0HHQzft4pxgBY3O"

```

```{r}
#| label: retrieve-snapshot-func


get_latest_snapshot <- function(base_folder_id = base_folder_id1) {
  tryCatch({
    # List all folders in the base directory
    folders <- googledrive::drive_ls(as_id(base_folder_id), pattern = "^\\d{8}$")
    
    if(nrow(folders) == 0) {
      stop("No dated folders found")
    }
    
    # Sort folders by name (date) in descending order
    latest_folder <- folders[order(folders$name, decreasing = TRUE),][1,]
    
    # Find the snapshot file in the latest folder
    snapshot_file <- googledrive::drive_ls(
      latest_folder$id, 
      pattern = "Registry data snapshot\\.xlsx$"
    )
    
    if(nrow(snapshot_file) == 0) {
      stop("No snapshot file found in latest folder")
    }
    
    # Return both pieces of information as a list
    return(list(
      snapshot = snapshot_file,
      folder_name = latest_folder$name
    ))
    
  }, error = function(e) {
    stop(paste("Error finding latest snapshot:", e$message))
  })
}
```

A general text cleaning function was constructed to apply during first import of raw data files, built on *tidyverse* and *stringr*. The *janitor* package was utilised to clean column names in the resulting dataframe.

```{r}
#| label: clean-text-func


# Generalized text cleaning function
clean_text <- function(text) {
  text |> 
    stringr::str_to_lower() |>
    stringr::str_squish() |>
    stringr::str_replace_all("\\.|\\. |\\: |\\, |w\\/", "; ") |>
    stringr::str_replace_all(";+", "; ") |>
    stringr::str_remove_all("^;|;$")
}

```

```{r}
#| label: bind-clean-func

bind_and_clean <- function(df1, df2, cols = NULL, clean_cols = NULL, clean_fn = clean_text) {
  # Store the names of the input dataframes
  df1_name <- deparse(substitute(df1))
  df2_name <- deparse(substitute(df2))
  
  # Bind rows
  result <- bind_rows(df1, df2)
  
  # If cols is specified, select those columns, otherwise keep all columns
  if (!is.null(cols)) {
    result <- result |> dplyr::select(all_of(cols))
  }
  
  # Apply text cleaning to specified columns
  if (!is.null(clean_cols)) {
    for (col in clean_cols) {
      if (col %in% names(result)) {
        result[[col]] <- clean_fn(result[[col]])
      } else {
        warning(glue::glue("Column '{col}' not found in dataframe"))
      }
    }
  }
  
  # Remove the input dataframes from the parent environment
  rm(list = c(df1_name, df2_name), envir = parent.frame())
  
  # Clean column names for consistency
  result |> janitor::clean_names(
    case = "big_camel"
  )
}

```

### Diagnosis

Include a series of functions for calling later in the file to process sub-phases of converting clinical text stored in the registry to categories of pathology affecting the foot and ankle. The functions were built on *tidyverse* and *stringr* packages to manipulate data, *future* and *furrr* to enable distributed processing of the records. The *progressr* package was utlised to enable visual progress to be communicated during processing and *memoise* to cache processing results from batches of subsets of the registry dataset to enable distributed processing.

```{r}
#| label: diagnosis-process-func-1

# Enable parallel processing
future::plan(multisession)

# Configure progress reporting
progressr::handlers("progress")

# Create a shared cache (in memory or filesystem)
shared_cache <- memoise::cache_memory()

# Memoize the target terms loading to match original format
load_target_terms <- memoise::memoise(function(sheet_url, sheet_name = "DiagTerm", range = "A1:C") {
  terms <- googlesheets4::range_read(
    ss = sheet_url,
    sheet = sheet_name,
    range = range,
    col_names = TRUE,
    trim_ws = TRUE
  ) |> 
    mutate(TargetTerm = paste0("\\b", stringr::str_escape(Term), "\\b"))
  
  list(
    terms = terms,
    pattern = str_c(terms$TargetTerm, collapse = "|")
  )
})

# Target-Replacement Function
create_replace_function <- function(target_terms_df) {
  function(string) {
    # Find the matched term in target_terms_df
    match <- filter(target_terms_df, Term == string)
    
    # Check if a match is found
    if (nrow(match) == 1) {
      return(match$ReplaceTerm)
    } else {
      # Return the original string if no match is found
      return(string)
    }
  }
}

clean_diagnosis_text <- memoise::memoise (function(df) {
  df |> 
    dplyr::select(TreatmentID, DiagnosisRawFinal, DiagnosisRawPrelim) |> 
    tidyr::unite("DiagnosisRaw", c(DiagnosisRawFinal, DiagnosisRawPrelim), 
          na.rm = TRUE, remove = FALSE, sep = "; ") |> 
    filter(stringr::str_count(str_to_lower(DiagnosisRaw), "") > 1) |> 
    mutate(
      DiagnosisRaw = stringr::str_squish(DiagnosisRaw),
      DiagnosisRaw = stringr::str_replace_all(DiagnosisRaw, "\\.|\\. |\\: |\\, |w\\/", ";"),
      DiagnosisRaw = stringr::str_replace_all(DiagnosisRaw, "\\#", "fracture"),
      DiagnosisRaw = stringr::str_replace_all(DiagnosisRaw, ";+", ";"),
      DiagnosisRaw = stringr::str_trim(stringr::str_remove_all(DiagnosisRaw, "^;|;$"))
    )
})

# Modified process_batch1 to maintain sequence integrity
process_batch1 <- function(batch_df) {
  batch_df |> 
    mutate(
      DiagnosisRaw1 = stringr::str_replace_all(
        str_to_lower(DiagnosisRaw), 
        "\\bwith\\b|\\band\\b|\\bas well as\\b", ";"
      ),
      DiagnosisRaw1 = stringr::str_replace_all(DiagnosisRaw1, "\\s+", " "),
      DiagnosisRaw1 = stringr::str_trim(DiagnosisRaw1)
    ) |> 
    tidyr::separate_rows(DiagnosisRaw1, sep = ";") |> 
    mutate(
      DiagnosisRaw1 = stringr::str_trim(DiagnosisRaw1),
      # Add row identifier before unnesting
      SequenceID = row_number()
    ) |> 
    filter(nchar(DiagnosisRaw1) > 0) |>
    tidytext::unnest_tokens(
      output = Term,
      input = DiagnosisRaw1,
      token = "regex",
      pattern = "\\s+",
      format = "text",
      to_lower = TRUE,
      drop = FALSE
    ) |>
    anti_join(stop_words, by = c("Term" = "word")) |>
    mutate(
      TermLength = stringr::str_length(Term),
      # Maintain original ordering within each diagnosis
      term_sequence = row_number()
    ) |>
    group_by(TreatmentID, SequenceID) |>
    mutate(
      term_count = n(),
      term_position = row_number()
    ) |>
    ungroup()
}

# Modified process_batch2 to preserve sequence information
process_batch2 <- function(batch_df, target_terms) {
  replace_function <- create_replace_function(target_terms$terms)
  
  batch_df |> 
    mutate(
      Term1 = stringr::str_replace_all(Term, target_terms$pattern, replace_function)
    ) |> 
    filter(
      stringr::str_detect(
        Term1, 
        "\\d+(?!(?:st|nd|rd|th)\\b)|(left|right)", 
        negate = TRUE
      )
    ) |>
    # Preserve grouping and sequence
    arrange(TreatmentID, SequenceID, term_position)
}

# Modified tokenize_diagnosis to handle sequence preservation
tokenize_diagnosis <- memoise::memoise(function(df, stop_words = NULL, batch_size = 500, process_batch) {
  if (is.null(stop_words)) {
    stop_words <- tidytext::get_stopwords()
  }
  
  if (missing(process_batch)) {
    stop("You must provide a process_batch function.")
  }
  
  # Add global identifier before splitting
  df <- df |> mutate(global_id = row_number())
  
  # Split the data into batches
  df_split <- split(df, ceiling(seq_len(nrow(df)) / batch_size))
  
  # Process batches while maintaining order
  furrr::future_map_dfr(df_split, process_batch, .progress = TRUE) |>
    arrange(global_id, term_position)
})

```

```{r}
# Term replacement logic
apply_target_terms <- memoise::memoise(function(df, target_terms, batch_size = 500, process_batch) {
  # Ensure `process_batch` is provided
  if (missing(process_batch)) {
    stop("You must provide a process_batch function.")
  }
  
  # Split the data into batches
  df_split <- split(df, ceiling(seq_len(nrow(df)) / batch_size))
  
  # Process each batch using the provided `process_batch` function
  furrr::future_map_dfr(df_split, ~process_batch(.x, target_terms), .progress = TRUE)
})
```

```{r}
# Function to safely process diagnosis
safe_process_diagnosis <- function(
    snapshot_df,
    target_terms_url,
    stop_words = NULL,
    batch_size = 1000,
    tokenize_batch = process_batch1,
    term_batch = process_batch2,
    workers = 4
    ) {    # Add workers parameter
  
  # Set up parallel processing
  old_plan <- plan(multisession, workers = workers)
  on.exit(plan(old_plan), add = TRUE)  # Ensure we reset the plan when done
  
  # Set up progress handling
  handlers("progress")
  
  tryCatch({
    with_progress({
      p <- progressor(steps = 4)
      
      # Load target terms
      p(message = "Loading target terms...")
      terms_data <- load_target_terms(target_terms_url)
      
      # Process the diagnosis data with progress updates
      p(message = "Cleaning text...")
      cleaned_data <- clean_diagnosis_text(snapshot_df)
      
      # Ensure stop_words is available
      if (is.null(stop_words)) {
        stop_words <- tidytext::get_stopwords()
      }
      
      # Create the tokenize batch function closure
      tokenize_batch_fn <- function(batch_df) {
        process_batch1(batch_df)
      }
      
      environment(tokenize_batch_fn)$stop_words <- stop_words
      
      p(message = "Tokenizing diagnosis...")
      tokenized_data <- tokenize_diagnosis(
        df = cleaned_data, 
        stop_words = stop_words,
        batch_size = batch_size,
        process_batch = tokenize_batch_fn
      )
      
      p(message = "Applying target terms...")
      processed_data <- apply_target_terms(
        df = tokenized_data, 
        target_terms = terms_data,
        batch_size = batch_size,
        process_batch = term_batch
      )
      
      processed_data
    })
  }, error = function(e) {
    message("Error in processing: ", e$message)
    # Clean up any remaining connections or resources
    future:::ClusterRegistry("stop")
    stop(e)
  })
}


```

Function to conduct categorisation of terms for pathology (diagnosis) stored in the registry.

```{r}
#' Categorize medical diagnoses with anatomical and pathological classifications
#' @param df A dataframe containing Term2 columns
#' @param remove_intermediate Logical, whether to remove intermediate processing columns
#' @param use_parallel Logical, whether to use parallel processing for large datasets
#' @param chunk_size Integer, number of rows to process in each parallel chunk
#' @return A dataframe with new classification columns based on Term2 pattern matching
categorize_diagnosis <- function(
    df,
    remove_intermediate = TRUE,
    use_parallel = TRUE,
    chunk_size = 1000
    ) {
  
  # Input validation with more detailed error message
  required_cols <- c("Term2")
  if(!all(required_cols %in% names(df))) {
    stop("Missing required column 'Term2'. Available columns are: ", 
         paste(names(df), collapse = ", "))
  }
  
  # Ensure df is a data.frame
  df <- as.data.frame(df)
  
  # Main processing function
  process_chunk <- function(chunk_df) {
    # Ensure required packages are loaded in parallel context
    require(dplyr)
    require(stringr)
    
    # Convert chunk to data.frame to ensure consistent behavior
    chunk_df <- as.data.frame(chunk_df)
    
    chunk_df |> 
      # Extract diagnosis side
      mutate(
        # Anatomical classifications
        Ankle = if_else(str_detect(chunk_df$Term2, "ankle|tibiotalar|\\bplafond\\b|dome|malleol*|weber|achilles|tendo-achilles|fibula|\\btibia\\b|gutter|perone*|syndesmo|gastrocnemius|talo-fibular|talofibular|calcaneofibular|calcaneo-fibular|gutter|(lateral|medial)\\s+ligament|tibia|deltoid|compartment.+syndrome") & str_detect(chunk_df$Term2,"(lateral|medial)\\s+collateral\\s+ligament", negate = TRUE),1,0),
        
        Hindfoot = if_else(str_detect(chunk_df$Term2, "\\btarsal\\b|\\btalar(?!\\s+dome)|talus|talonavic*|plantar|(rear|hind)foot|trigonum|hindfeet|tarsi|calcaneus|\\bcalcaneal\\b|heel|subtalar"),1,0),
        
        Midfoot = if_else(str_detect(chunk_df$Term2, "metatarsus|tarsometatarsal|tarso-metatarsal|\\bmetatarsal\\b|talonavicular|navicular|cuneiform|lisfranc|cuboid|midfoot|jones|chopart"),1,0),
        
        Forefoot = if_else(str_detect(chunk_df$Term2, "digit*|morton*|metatarsophalangeal|phalange*|phalanx|hallux|nail|forefoot|forefeet|bunionette|hallucis|onychomycosis|paronychia|bunion|hammertoe|claw|sesamoid"),1,0),
        
        Foot = if_else(str_detect(chunk_df$Term2, "\\bfeet\\b|\\bfoot\\b|cavovarus|equinovarus|equinus|pes|charcot|footdrop|neuropathy"),1,0)
      ) |>
      # Pathological classifications
      mutate(
        Arthritis = if_else(str_detect(chunk_df$Term2, "psoria|arthritis|osteoarthritis|rheumatoid|gout|erosion|arthropathy"),1,0),
        
        Injury = if_else(str_detect(chunk_df$Term2, "injury|injuries|axial|impact|crush|rotation|inversion|forced|accident|tear|torn|ruptur|avulsion|fracture|defect|(osteochondral|chondral|cartilage).+lesion|sprain|haemarthrosis|disruption|wound|laceration|penetrating|hernia|maisonneuve"), 1, 0),
        
        Deformity = if_else(str_detect(chunk_df$Term2, "malalignment|deformit|angulation|contracture|contraction|\\bvalgus\\b|varus|planovalgus|valgoplanus|dysfunction|extension|adductus|crossover|hammer|claw|bunionette|bunion|interphalangeus|(relatively|significantly).+long|relative.+long"),1,0),
        
        Metatarsalgia = if_else(str_detect(chunk_df$Term2, "metatarsalgia|forefoot.+overload"),1,0),
        
        SoftTissueDisorder = if_else(str_detect(chunk_df$Term2, "tenosynovitis|enthesopathy|teno-synovitis|tendinopathy|tendinitis|tendonitis|tendinosis|fasciosis|fasciitis|sesamoiditis|arthrofibro|scar|tibialis posterior.+dysfunction|dysfunction tibialis posterior"),1,0),
        
        Growth = if_else(str_detect(chunk_df$Term2, "cyst|ganglion|neuroma|malformation|fibroma|tumour|accessory|ingrown|in_grown|coalition|(?<!(?:chondral|osteochondral|cartilage)\\s)\\blesion\\b|xanthomas|osteoma|gioma|schwannoma|chondroma|lump|villonodular|callosity|corn|mass|\\b(non|mal|delayed)[-]?union|pseudo-articulation|bone.+loss|exostosis|spur|osteophyte|onychogryphosis|bipartite|neuroma|chondromatosis"), 1, 0),
        
        Neural = if_else(str_detect(chunk_df$Term2, "foot.+drop|footdrop|nerve|neuropathy|neural|sensory|charcot|motor|pain.+syndrome|tunnel.+syndrome|neuropathic|denervation"),1,0),
        
        Infection = if_else(str_detect(chunk_df$Term2, "infect|osteomyelitis|cellulitis|onychomycosis|ulcer|paronychia"),1,0),
        
        Impingement = if_else(str_detect(chunk_df$Term2, "impingement|stiffness|os.+trigonum"),1,0),
        
        Instability = if_else(str_detect(chunk_df$Term2, "disloc|unstable|sublux|instability|talar.+shift|widening|maisonneuve"),1,0)
      ) |>
      # Final classifications
      mutate(
        Other = if_else(rowSums(across(c(Arthritis:Instability))) < 1 | str_detect(chunk_df$Term2,"foreign.+(body|material)"),1,0),
        NegatePathology = if_else(str_detect(chunk_df$Term2, "(?<!ab?)normal|(?<!(non|mal)-?)|nil.+pathology|\\bheal\\b|reduced|non-tender|unremarkable"),0,1)
      )
  }
  
  # Process data based on parallel preference
  if (use_parallel && nrow(df) > chunk_size) {
    # Ensure required packages are loaded in main session
    require(future)
    require(furrr)
    
    # Set up parallel processing
    plan(multisession)
    
    # Create chunks with explicit data.frame conversion
    chunks <- split(df, ceiling(seq_len(nrow(df))/chunk_size))
    chunks <- lapply(chunks, as.data.frame)
    
    # Process chunks in parallel
    df_processed <- future_map_dfr(chunks, process_chunk, .progress = TRUE)
  } else {
    df_processed <- process_chunk(df)
  }
  
  return(df_processed)
}

# Create cached version
categorize_diagnosis_cached <- memoise::memoise(categorize_diagnosis)
```

Concatenated terms for each treatment record using *tidyverse* syntax. Generated a method to cumulatively concatenate terms within a treatment record that have been split into text sequences delimited by punctuation (e.g. ";").

```{r}
concatenate_diagnoses <- function(data) {
  # Sort the data by TreatmentID and SequenceRow in descending order
  data |>
    arrange(TreatmentID, desc(SequenceRow)) |>
    group_by(TreatmentID) |>
    mutate(
      CumulativeTerm = accumulate(Term2, 
                                 .f = function(x, y) {
                                   if (is.na(x)) y else paste(y, x, sep = "; ")
                                 }) |> 
        last()
    ) |>
    ungroup()
}

```

```{r}

concatenate_cumulative <- function(SequenceRow, ProductCuml, Term2) {
  # Create a dataframe to help with tracking
  df <- data.frame(
    SequenceRow = SequenceRow, 
    ProductCuml = ProductCuml, 
    Term2 = Term2,
    stringsAsFactors = FALSE
  )
  
  # Sort by SequenceRow to ensure correct processing
  df <- df[order(df$SequenceRow), ]
  
  # Initialize result vector
  result <- character(length(SequenceRow))
  
  # Use accumulate to build up the terms
  accumulated_result <- purrr::accumulate(
    1:nrow(df), 
    .init = list(
      accumulated_terms = character(),
      last_classified_term = NA_character_
    ),
    function(acc, i) {
      # Current row details
      current_term <- df$Term2[i]
      current_product_cuml <- df$ProductCuml[i]
      
      # If current row is classified (ProductCuml >= 1)
      if (current_product_cuml >= 1) {
        # Concatenate all accumulated terms with current term
        if (length(acc$accumulated_terms) > 0) {
          combined_term <- str_c(
            str_c(acc$accumulated_terms, collapse = "; "), 
            current_term, 
            sep = "; "
          )
        } else {
          combined_term <- current_term
        }
        
        # Return updated state
        list(
          accumulated_terms = character(),
          last_classified_term = combined_term
        )
      } else {
        # Accumulate terms for rows with ProductCuml < 1
        list(
          accumulated_terms = c(acc$accumulated_terms, current_term),
          last_classified_term = acc$last_classified_term
        )
      }
    }
  )
  
  # Extract the last_classified_term for each row
  result <- sapply(accumulated_result[-1], `[[`, "last_classified_term")
  
  # Ensure result matches original input order
  result[order(SequenceRow)] <- result
  
  return(result)
}

```


# Title and abstract

<!--# Indicate the study’s design with a commonly used term in the title or the abstract. Provide in the abstract an informative and balanced summary of what was done and what was found -->

The following working title is proposed;

::: {#workingtitle style="color: gray"}
Recovery of pain and function following surgical treatment foot and ankle pathology: A cohort analysis of the SOFARI Registry
:::


## Abstract

::: {#abstract style="color: gray"}
Purpose: There is a lack of information regarding the most appropriate confounders that should be included in analysis of clinical and patient-reported outcomes in foot and ankle orthopaedic conditions. The purpose of this study was to describe pain, function and quality of life across a broad range of orthopaedic conditions and i) assess the relationship between potential confounders to followup outcomes (anatomical region of presentation and presence of arthritis).

Methods: A cross-sectional analysis was performed on data stored in a specialty, clinician-funded quality registry (SOFARI) of four specialist practices in Sydney, Australia between Jun-2020 and May-2025. Pain, function and quality of life (FAOS) was captured via electronic forms at initial presentation of each patient to the participating surgeon, in addition to patient demographics and other patient-reported outcome data (Comorbidities, pain catastrophising, general health). Missing data was addressed using multiple imputation via chained equations (mice). A linear model of anatomical region was generated to assess its effects on all subscales of the FAOS in both unadjusted and adjusted forms. The minimal adjustment set was identified using directed acyclic graphs from a candidate set of variables.

Results: A cohort of 13652 index (first presentation to registry) treatments was extracted and included in the dataset after applying inclusion and exclusion criteria. Of these, 29.4% of cases involved the ankle in isolation, with 21.9% presenting with pathology affecting multiple regions of the foot and ankle. Significant main effects of anatomical region were observed for all FAOS subscales after adjustment, with isolated forefoot cases consistently displaying higher average scores at baseline assessment compared to other regions and cases presenting with multiple regions affected. These differences ranged from 14.6 points (95%CI 13.2 - 16.0) between ankle and forefoot for the Pain subscale to 25.8 (95%CI 23.8 - 27.9) for the same contrast in the Sport subscale. Overall, the effect of arthritis on average subscale scores was significant for all subscales except Activities of Daily Living. When a sub-analysis was performed comparing isolated ankle arthritis to non-arthritis cases of the ankle and cases with pathology spanning multiple regions and including an arthritis diagnosis, significant, but small effects were observed for all FAOS subscales expect for Symptoms, which displayed a medium effect.

Conclusion: Pain, function and quality of life differ between patients presenting with isolated forefoot pathology compared to other foot-ankle regions. Future work should consider the collection of patient-reported outcomes separately for forefoot compared to the remaining anatomical regions, to avoid potential ceiling effects in forefoot patients during assessment post-treatment. The present results may assist in counselling patient expectations with respect to pain relief in response to treatment, particularly when pathology presents localised to certain anatomical regions. In addition, interventions targeting a patient’s relationship with pain may be a useful adjunct to contemporary treatment modalities.
:::

## RECORD \[1.1\] Data Type

<!--# RECORD 1.1: The type of data used should be specified in the title or abstract. When possible, the name of the databases used should be included. -->

Data type included in Title.

## RECORD \[1.2\] Geography and Timeframe

<!--# RECORD 1.2: If applicable, the geographic region and timeframe within which the study took place should be reported in the title or abstract. -->

Included in abstract.

## RECORD \[1.3\] Data Linkage

<!--# RECORD 1.3: If linkage between databases was conducted for the study, this should be clearly stated in the title or abstract -->

No data linkage to another data was performed for this analysis.

## RECORD \[2\] Background/rationale

<!--# Explain the scientific background and rationale for the investigation being reported -->





## RECORD \[3\] Objectives

<!--# State specific objectives, including any prespecified hypotheses -->

PICOS question format

::: {#tbl-questions}
+--------------+--------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| Component    | Question 1                                                                                                                           | Question 2                                                                                                                           |
+==============+======================================================================================================================================+======================================================================================================================================+
| Population   | In patients presenting for orthopaedic surgical review of ankle or foot pathology to one of four private clinics in metropolitan NSW | In patients presenting for orthopaedic surgical review of ankle or foot pathology to one of four private clinics in metropolitan NSW |
+--------------+--------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| Intervention | with pathology affecting a specific region of the foot or ankle                                                                      | with any form of arthritis identified in the diagnosis derived from clinical notes                                                   |
+--------------+--------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| Comparator   | compared to pathology affecting other regions of the foot and ankle                                                                  | compared to those that do not                                                                                                        |
+--------------+--------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| Outcome      | how do the FAOS subscales differ?                                                                                                    | how do the FAOS subscales differ?                                                                                                    |
+--------------+--------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| Study Design | Cross-sectional analysis of a multi-site clinical quality registry                                                                   | Cross-sectional analysis of a multi-site clinical quality registry                                                                   |
+--------------+--------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+

Analysis questions presented in PICOS format
:::

### Hypotheses

Clinical and statistical hypotheses presented in tabular format

::: {#tbl-hypotheses}
+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Hypotheses  | Question 1                                                                                                                                                                                                                                                                                                         | Question 2                                                                                                                                                                                    |
+=============+====================================================================================================================================================================================================================================================================================================================+===============================================================================================================================================================================================+
| Clinical    | After adjusting for identified confounders, patients with pathology affecting specific anatomical regions of the foot or ankle will demonstrate clinically meaningful differences in FAOS subscale scores compared to patients with pathology in other regions, reflecting region-specific functional impairments. | After adjusting for identified confounders, patients with arthritis will demonstrate significantly (and clinical important) worse FAOS subscale scores compared to patients without arthritis |
+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Statistical | -   **Null (H₀):** μ₁ᵢ - μ₂ᵢ = 0 for each FAOS subscale i, after covariate adjustment                                                                                                                                                                                                                              | -   **Null (H₀):** μₐᵢ - μₙᵢ = 0 for each FAOS subscale i, after covariate adjustment                                                                                                         |
|             | -   **Alternative (H₁):** μ₁ᵢ - μ₂ᵢ ≠ 0 for at least one FAOS subscale i, after covariate adjustment                                                                                                                                                                                                               | -   **Alternative (H₁):** μₐᵢ - μₙᵢ \< 0 for at least one FAOS subscale i, after covariate adjustment                                                                                         |
+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Clinical and statistical hypotheses for question 1 and 2. μ₁ᵢ and μ₂ᵢ represent the adjusted mean scores for FAOS subscale i in the specific region group and other regions group, respectively.
:::

The hypotheses presented in @tbl-hypotheses posit that the variables of interest will be associated with *clinically important* differences in FAOS subscales. For the purposes of the present analysis the approach of [@fatima2022] is replicated here and a general threshold of 8 points is used as a threshold to identify an important difference due to the variables of interest. However, this is provided with some caveats given the evolution of our understanding of these metrics over time. It should be noted that the minimal clinically important difference for the FAOS is sensitive to a range of factors (diagnosis, followup duration) [@sierevelt2024], baseline score [@sierevelt2015] and calculation methods [@Tenan2021]. Broadly speaking, the MCID for the FAOS may range somewhere between \<4 for the *Symptoms* subscale to 11.7 for the ADL subscale [@tapaninaho2022], with variation reported in other studies investigating MCID in FAOS [@sierevelt2015; @desai2019].

# Methods

## RECORD \[4\] Study design

<!--# Present key elements of study design early in the paper -->

Cross-sectional analysis of registry data.


## RECORD \[5\] Setting

<!--# Describe the setting, locations, and relevant dates, including periods of recruitment, exposure, follow-up, and data collection -->

The SOFARI (Sydney Orthopaedic Foot and Ankle Research Institute) registry is a multi-site system based in Sydney, Australia. It commenced recruitment with one specialist in Jun-2020 and was expanded sequentially to three other specialists by Aug-2021.

Patients were recruited in an opt-out consent model through electronic communication (sms, email) at the time of their initial consultation with their surgeon. Recruitment and data collection into the registry for the present analysis spans 6-Jun-2020 to 31-Jan-2025.

## RECORD \[8\] Data sources/measurement

<!--# For each variable of interest, give sources of data and details of methods of assessment (measurement). Describe comparability of assessment methods if there is more than one group -->

Data was sourced directly from the SOFARI registry. Patient and treatment information were entered into the database through the registry interface and compiled into a data cube (snapshot) every quarter. Complications and adverse events captured into an online form (QuestionPro, USA) and linked using record identifier codes. Patient-reported outcomes were collected from the patient through electronic communication (sms, email) of a form link specific to baseline assessment and captured into an online form (QuestionPro, USA) for each questionnaire of interest. PROMs data were also linked back to patient and treatment infromation using record identifier codes.

### Data Import and Preparation

Data was retrieved and formatted using *openxlsx* to retrieve static snapshot files and *googlesheets4* to retrieve live database tables. Text and code output were integrated using the *epoxy* package. Source files were specified and stored as global variables to call on in further functions.

```{r}
#| label: source-ids
#| echo: false

SheetIDs <- list(
  Complic1 = "https://docs.google.com/spreadsheets/d/1hs9AHor_cqEOzFBpXHLrcrb2Gs3Ot647g8aMYfax6Fw/edit",
  Complic2 = "https://docs.google.com/spreadsheets/d/1nFMsHl_LEm4tVi7GGtArGWB3EkG3YE_rF5C-PUcAgMs/edit",
  Patient1 = "https://docs.google.com/spreadsheets/d/1hs9AHor_cqEOzFBpXHLrcrb2Gs3Ot647g8aMYfax6Fw/edit",
  Patient2 = "https://docs.google.com/spreadsheets/d/1nFMsHl_LEm4tVi7GGtArGWB3EkG3YE_rF5C-PUcAgMs/edit"
  
)

```

Read in patient tables, then combine and clean the text columns as required.

```{r}
#| label: import-patienttable

# Authenticate for sheets using the same token
gs4_auth(token = drive_token())

PatientTable1 <- range_read(
  ss = SheetIDs$Patient1,
  sheet = "Patient",
  col_names = c(
  "PatientCreationDate",
  "PatientID",
  "LastName",
  "FirstName",
  "AlternateID",
  "DateOfBirth",
  "Sex",
  "RegistryStatus",
  "RegistryStatusNotes",
  "DateRegistryStatus",
  "NotificationMethod",
  "NoTreatmentRecords",
  "Email",
  "Phone",
  "Postcode",
  "PatientRegistrationStatus",
  "DatePatientRegistration",
  "TrueNoTreatmentRecords"
),
range = "A6:R",
col_types = "DccccDcccTciccccTi"
)

PatientTable2 <- range_read(
  ss = SheetIDs$Patient2,
  sheet = "Patient",
  col_names = c(
  "PatientCreationDate",
  "PatientID",
  "LastName",
  "FirstName",
  "AlternateID",
  "DateOfBirth",
  "Sex",
  "RegistryStatus",
  "RegistryStatusNotes",
  "DateRegistryStatus",
  "NotificationMethod",
  "NoTreatmentRecords",
  "Email",
  "Phone",
  "Postcode",
  "PatientRegistrationStatus",
  "DatePatientRegistration",
  "TrueNoTreatmentRecords"
),
range = "A6:R",
col_types = "DccccDcccTciccccTi")


MasterPatient <- bind_rows(
  PatientTable1,
  PatientTable2
) |> mutate(
  AlternateID2 = stringr::str_remove(AlternateID,"MS1|MS2")
) |> group_by(
  PatientID
) |> mutate(
  RecordNum = row_number()
) |> ungroup()

rm(PatientTable1,
  PatientTable2
)
```


Read in complication tables, then combine and clean the text description of complications as required.

```{r}
#| label: import-complication
#| eval: false
#| echo: false

# Authenticate for sheets using the same token
gs4_auth(token = drive_token())

ComplicTable1 <- googlesheets4::read_sheet(
  ss = SheetIDs$Complic1,
  sheet = "Complications",
  range = "A2:AD",
  col_names = TRUE,
  col_types = "cccTlnicicccccccccccicccccDccD"
)

ComplicTable2 <- range_read(
  ss = SheetIDs$Complic2,
  sheet = "Complications",
  range = "A2:AD",
  col_names = TRUE,
  col_types = "cccTlnicicccccccccccicccccDccD"
)

# Complication Table
MasterComplic <- bind_and_clean(
  df1 = ComplicTable1, 
  df2 = ComplicTable2, 
  cols = c(
    "TreatmentID", 
    "ComplicationID", 
    "ComplicationOccurrence",
    "ComplicationNature", 
    "DateOfOccurrence",
    "ComplicationTreatmentOffered",
    "DateReoperation"),
  clean_cols = "ComplicationNature",
  clean_fn = clean_text  # Pass the function directly
)

```

Process the registry snapshot by retrieving the file and use *tidyverse* to add columns, recode existing columns and create an additional identifier using *tidyr*, representing the patient and their side, to track multiple treatments for each limb. Dates were reformatted to a form appropriate for analysis using *lubridate*. The snapshot is initially processed using custom functions to retrieve datatables and apply eligibility criteria for each treatment

```{r}
#| label: import-snapshot


# Get the latest snapshot file
latest_snapshot <- get_latest_snapshot()
# 
# You can then use these in your subsequent code:
temp_file <- tempfile(fileext = ".xlsx")
drive_download(
  file = latest_snapshot$snapshot$id,
  path = temp_file,
  overwrite = TRUE
)

# Correction to reset back to excel origin
DaysDiff <- as.numeric(as.duration(interval(ymd("1899-12-30"), ymd("1970-01-01"))),"days")

Snapshot <- read_xlsx(
  temp_file,
  sheet = "General",
  colNames = TRUE,
  detectDates = FALSE
  ) |>
  mutate(
        # Convert to dates
        across(
            starts_with("Date"),
            ~lubridate::as_date(., origin = "1899-12-30")
        ),
        # Then get the numeric values directly
        across(
            starts_with("Date"),
            ~as.numeric(.)+ DaysDiff,
            .names = "{.col}Num"
        ),
        Sex2 = case_when( # Fix up sex entries
          Sex == "M" ~ "Male",
          Sex == "Male" ~ "Male",
          Sex == "F" ~ "Female",
          Sex == "Female" ~ "Female",
          Sex == "N" ~ NA_character_,
          .default = NA_character_
        ),
        PatientID = stringr::str_split_i(TreatmentID,"\\.",1)
    ) |> left_join(
    MasterPatient |> dplyr::select(
    PatientID,
    AlternateID2,
    AlternateID
),
by = "PatientID",
relationship = "many-to-many"
) |> tidyr::unite(
  "CombID",
  c("PatientID","AffectedSide"),
  sep = ".",
  na.rm = FALSE,
  remove = FALSE
) |> group_by(
  CombID
) |> arrange(
  DateInitialExaminationNum
  ) |> mutate(
  RecordNum = row_number()
) |> ungroup() |> 
    relocate(
        c(PatientID, ends_with("Num"),RecordNum),
        .before = TreatmentID
    ) 


#Import STROBEInput to conduct flowchart and record selection "Strobe_Input"

STROBEInput <- read_xlsx(
  temp_file,
  sheet = "Strobe_Input",
  colNames = TRUE,
  detectDates = FALSE
  )

# Clean up
unlink(temp_file)

```



## RECORD \[6\] Participants

<!--# (a) Cohort study—Give the eligibility criteria, and the sources and methods of selection of participants. Describe methods of follow-up -->

Participants are eligible for inclusion in the SOFARI registry if they meet the following criteria

-   Presented with a pathology localised to the foot or ankle

-   Offered or recommended treatment by the reviewing surgeon (operative or non-operative)

-   Aged 16 or over at the time of initial consultation for the condition included in the registry

-   Have not withdrawn their data from the registry (opt-out)

### Record \[6.1\] Sample selection

<!--# RECORD 6.1: The methods of study population selection (such as codes or algorithms used to identify subjects) should be listed in detail. If this is not possible, an explanation should be provided. -->

Record selection was based on the following criteria;

-   The status of the record was not set to *Archived* (the treatment record does not meet inclusion into the registry).

-   The status of the record was not set to *Pending Initial Consultation* or *Pending Imaging* (not eligible for formal diagnosis).

-   The record represented the first presentation for the limb within the registry. This may not represent the first presentation to the clinic.

-   The diagnosis includes ankle osteoarthritis


<!--# (a) Going to need to have one list for strobe flow and another to run the impuation from -->


### Record \[6.2\] Algorithm validation

<!--# RECORD 6.2: Any validation studies of the codes or algorithms used to select the population should be referenced. If validation was conducted for this study and not published elsewhere, detailed methods and results should be provided. -->

### Record \[6.3\] Data linkage

<!--# RECORD 6.3: If the study involved linkage of databases, consider use of a flow diagram or other graphical display to demonstrate the data linkage process, including the number of individuals with linked data at each stage. -->

No data linkage was performed for this analysis.

## RECORD \[7\] Variables

<!--# Clearly define all outcomes, exposures, predictors, potential confounders, and effect modifiers. Give diagnostic criteria, if applicable -->

Key variables defined as part of this analysis are summarised below and retrieved from the core dataset of the SOFARI registry.

::: {#tbl-variables}
+-------------+-----------------------------------------+----------------------------------------------------------------------------------------+---------------+
| Category    | Variable                                | Definition - Comments                                                                  | Citation      |
+=============+=========================================+========================================================================================+===============+
| Outcomes    | FAOS                                    | 42-question with 5 subscales (Pain, ADL, Sport, Symptoms, Quality of Life)             | [@roos2001]   |
+-------------+-----------------------------------------+----------------------------------------------------------------------------------------+---------------+
| Exposures   | Cohort (Region)                         | categorisation of pathology based on anatomical region                                 |               |
+-------------+-----------------------------------------+----------------------------------------------------------------------------------------+---------------+
|             | Arthritis                               | Binary flag as to whether an arthritis diagnosis was included in the clinical notes    |               |
+-------------+-----------------------------------------+----------------------------------------------------------------------------------------+---------------+
| Confounders | Age                                     | age at the date of initial examination                                                 |               |
+-------------+-----------------------------------------+----------------------------------------------------------------------------------------+---------------+
|             | Sex                                     | self-reported by the patient (male, female)                                            |               |
+-------------+-----------------------------------------+----------------------------------------------------------------------------------------+---------------+
|             | Bilateral Presentation                  | Whether there is pathology present on one or both limbs such that treatment is offered |               |
+-------------+-----------------------------------------+----------------------------------------------------------------------------------------+---------------+
|             | Comorbidity score                       | Self-assessed comorbidity score (SACQ) sum of 12 items rated 0 - 3                     | [@Sangha2003] |
+-------------+-----------------------------------------+----------------------------------------------------------------------------------------+---------------+
|             | Smoking History                         | categorical variable outlining patient smoking history relative to 12month cessation   |               |
+-------------+-----------------------------------------+----------------------------------------------------------------------------------------+---------------+
|             | VR12- MCS                               | 12-question general health questionnaire                                               | [@Selim2009]  |
|             |                                         |                                                                                        |               |
|             |                                         | Produces mental and physical sub-scores                                                |               |
+-------------+-----------------------------------------+----------------------------------------------------------------------------------------+---------------+
|             | Pain catastrophising scale - Short form | 7-question short version of the PCS                                                    | [@cheng2019]  |
|             |                                         |                                                                                        |               |
|             |                                         | Total score from sum of individual items                                               |               |
+-------------+-----------------------------------------+----------------------------------------------------------------------------------------+---------------+

Summary of key variable definitions in the analysis
:::

The self-assessed comorbidity score had to be added to the dataset by calculating from individual responses included in the registry snapshot. The scores were then added to the analysis master table.

```{r}
# Apply to your data
SRCQScore <- MasterTable1 |> 
  dplyr::select(
    TreatmentID,
    starts_with("comorb")
  ) |> 
  mutate(
    across(starts_with("Comorb"), 
           ~ case_when(
             is.na(.) ~ NA,
             . == "I do not have the problem" ~ 0,
             . == "I have the problem" ~ 1,
             . == "I am receiving treatment for it" | 
               . == "I have the problem, I am receiving treatment for it" ~ 2,
             . == "The problem limits my activities" | 
               . == "I have the problem, I am receiving treatment for it, The problem limits my activities" ~ 3,
             TRUE ~ NA_real_  # Add default case
           )
    )
  ) |> 
  mutate(
    SRCQTotalScore = rowSums(across(where(is.numeric)))
  )
```

```{r}
#| label: mastertable-2
#| 
MasterTable2 <- MasterTable1 |> left_join(
  SRCQScore |> dplyr::select(
    TreatmentID,
    SRCQTotalScore
  ),
  by = "TreatmentID"
) |> dplyr::select(
  !(starts_with("Comorb"))
)
```

*Extract individual PCS scores*

```{r}
PCSTable  <- MasterTable1 |> 
  dplyr::select(
    TreatmentID,
    starts_with("PCSSF")
  ) |> 
  dplyr::mutate(
    across(starts_with("PCSSF"),
           ~as.numeric(stringr::str_extract(.,"\\d+"))
    )
  )

```

According to [@cheng2019] the PCS-SF (and perhaps the full scale as well) would be best scored by simply adding all the items up. The present analysis may provide a platform for future examination of subscales of PCS such as *Rumination*, *Magnification* and *Helplessness* with respect to baseline pain.

The PCS-SF total score was added to the master table.

```{r}
#| label: mastertable-3

MasterTable3 <- MasterTable2 |> dplyr::select(
  !(starts_with("PCSSF"))
) |> left_join(
  PCSTable |> dplyr::select(
    TreatmentID,
    PCSSF_TotalScore_Preop
  ),
  by = "TreatmentID"
) |> dplyr::select(
  TreatmentID,
  PatientID,
  CombID,
  DateTreatmentRecordCreation,
  TreatmentType,
  Sex2,
  Provider,
  TreatmentStatus,
  AgeAtInitialExam,
  SmokingStatus_Preop,
  InjuryToPresentation,
  VR12_Physical_TotalScore_Preop,
  VR12_Mental_TotalScore_Preop,
  SRCQTotalScore,
  PCSSF_TotalScore_Preop,
  Satisfaction_Preop,
  PreviousPath,
  PreviousSurgery,
  DiagnosisRawFinal,
  DiagnosisRawPrelim,
  SurgicalTreatment
)

```

*Extract individual PCS scores*

```{r}
FAOSTable  <- Snapshot |> dplyr::filter(
  TreatmentID %in% MasterTable1$TreatmentID
) |> dplyr::select(
    TreatmentID,
    starts_with("FAOS") & contains("TotalScore") & contains("Preop")
  ) |>
  dplyr::mutate(
    across(starts_with("FAOS"),
           ~as.numeric(stringr::str_extract(.,"\\d+"))
    )
  )

```

### Diagnosis

Raw text stored in the registry snapshot was processed with custom functions (see *Functions for Processing*). Additional processing was performed to create a *Region* label, describing the anatomical region in which the pathology affected.

```{r}
#| label: targeturl
#| echo: false


TargetURL = "https://docs.google.com/spreadsheets/d/1f-zb_pdjH9PuFSdkMBcAdyPCP_b-YJk2Jzvrn5G6df4/edit"

```

```{r}
#| label: diagnosis-term-1

#| eval: true
#| echo: false
#| message: false
#| warning: false



progressr::handlers("progress")

# Run the processing
with_progress({
  # Try processing with smaller batch size and fewer workers
# Update your safe_process_diagnosis call
DiagTerm <- safe_process_diagnosis(
  MasterTable2,
  target_terms_url = TargetURL,
  batch_size = 500,
  workers = 4
)
})

```

```{r}
#| label: diagnosis-sequence
# Group by sequence

DiagSequence <- DiagTerm |> tidyr::unite(
  "SequenceID1",
  c(TreatmentID,
    SequenceID
    ),
  na.rm = TRUE, 
  remove = FALSE, 
  sep = "."
  ) |> group_by(
    SequenceID1
    ) |> summarize(
    Term2 = str_c(Term1, collapse = " ")
  ) |> ungroup() |> mutate(
    TreatmentID = stringr::str_remove(SequenceID1, "\\.[^.]*$")
  )

# Group by Treatment

DiagTreatment <- DiagSequence |> group_by(
  TreatmentID
) |> summarise(
  Term3 = str_c(
    Term2,
    collapse = "; "
  )
) |> ungroup()


```

```{r}
#| label: diagnosis-categorise

#| eval: true
#| echo: false
#| message: false
#| warning: false

  
# With parallel processing
DiagFunc1 <- categorize_diagnosis(
  DiagSequence |> filter(
    stringr::str_detect(Term2,"history", negate = TRUE)
  ),
  remove_intermediate = FALSE,
  use_parallel = TRUE,
  chunk_size = 4000) |>
  mutate(
    SequenceRow = row_number(),
    has_region = rowSums(across(Ankle:Foot)),
    has_pathology = rowSums(across(Arthritis:Instability)),
   # RowTarget = SequenceRow - 1,
    .by = TreatmentID
  ) |> tidyr::unite(
    "SequenceIDUpdate",
    c(TreatmentID,SequenceRow),
    sep = ".",
    na.rm = FALSE,
    remove = FALSE
  ) 

```

```{r}
#| label: diagnosis-flag-fragments


DiagFunc2 <- DiagFunc1 |> 
  mutate(
    RowCount1 = n(),
    .by = TreatmentID
  ) |> 
  dplyr::select(
    -(Ankle:NegatePathology)
  ) |> 
  mutate(
    SequenceCat1 = if_else(
      has_region >= 1 & has_pathology >= 1,
      "Classified",
      "No"
    )
  ) |> 
  group_by(TreatmentID) |> 
  arrange(desc(SequenceRow), .by_group = TRUE) |> 
  mutate(
    Product = has_region * has_pathology,
    SequenceCatLead = lead(SequenceCat1),
    ResetFlag = case_when( 
      lag(Product) >= 1 & Product == 0 ~ 1,
      lag(Product) < 1 & Product < 1 ~ 1,
      Product >= 1 & lag(Product) < 1 ~ 1,
      SequenceRow == max(SequenceRow) & Product == 0 ~ 1,
      SequenceRow == max(SequenceRow) & Product >= 1 ~ 0,
      .default = 0
    )
  ) |> 
  ungroup()

```

```{r}
#| label: diagnosis-reduce-fragments

DiagFunc2a <- DiagFunc2 |> filter(
  Product > 0,
  ResetFlag == 0
)


DiagFunc2b <- left_join(
  DiagFunc2 |> filter(
    ResetFlag == 1
  ) |> distinct(
    TreatmentID,
    .keep_all = TRUE
  ),
DiagFunc2c <- DiagFunc2 |> filter(
  ResetFlag == 1
) |> group_by(
  TreatmentID
) |> summarise( # COLLAPSE rows into 1. JOIN back into FuncX (bindrows)
   Term3 = str_c(
     Term2,
     collapse = "; "
   )
 ),
by = "TreatmentID"
) |> ungroup() |> dplyr::select(
  -Term2
) |> rename(
  Term2 = "Term3"
)


DiagFunc3 <- bind_rows(
  DiagFunc2a,
  DiagFunc2b
) |> arrange(
  TreatmentID
) |> dplyr::select(
  -(has_region:ResetFlag)
)

```

```{r}
#| label: diagnosis-categorise-treatments
#| eval: true
#| echo: false
#| message: false
#| warning: false

  
# With parallel processing
DiagFunc4 <- categorize_diagnosis(
  DiagFunc3 |> filter(
    stringr::str_detect(Term2,"history", negate = TRUE)
  ),
  remove_intermediate = FALSE,
  use_parallel = TRUE,
  chunk_size = 4000) |>
  mutate(
    SequenceRow = row_number(),
    has_region = rowSums(across(Ankle:Foot)),
    has_pathology = rowSums(across(Arthritis:Instability)),
   # RowTarget = SequenceRow - 1,
    .by = TreatmentID
  )  |> filter(
  has_region*has_pathology >= 1
) |> tidyr::unite(
    "SequenceIDUpdate",
    c(TreatmentID,SequenceRow),
    sep = ".",
    na.rm = FALSE,
    remove = FALSE
  )

```

```{r}
#| label: diagnosis-region-1


DiagRegion <- DiagFunc4 |> dplyr::select(
  Term2,
  SequenceIDUpdate,
  TreatmentID:Foot
) |> dplyr:: select(
  -SequenceRow
) |> tidyr::pivot_longer(
  cols = !c(TreatmentID,SequenceIDUpdate,Term2),
  names_to = "Region",
  values_to = "RegionPresence"
) |> dplyr::filter(
  RegionPresence > 0,
  !is.na(Region)
) |> dplyr::mutate(
  RegionCount = n_distinct(Region),
  RegionCat = if_else(RegionCount > 1,"Multiple","Isolated"),
  .by = TreatmentID
) |> dplyr::select(
  -RegionPresence
)
```

```{r}
#| label: diagnosis-pathology-1

DiagPathology <- DiagFunc4 |> dplyr::select(
  Term2,
  TreatmentID,
  SequenceIDUpdate,
  Arthritis:Other
) |> tidyr::pivot_longer(
  cols = !c(TreatmentID,SequenceIDUpdate,Term2),
  names_to = "Pathology",
  values_to = "PathPresence"
) |> filter(
  PathPresence > 0,
  !is.na(Pathology)
) |> mutate(
  PathCount = n_distinct(Pathology),
  PathCat = if_else(PathCount > 1,"Multiple","Isolated"),
  .by = TreatmentID
)


```

```{r}
#| label: diagnosis-path-region

DiagRegion1 <- DiagRegion |> distinct(
  TreatmentID,
  .keep_all = TRUE
) 


DiagPath1 <- DiagPathology |> distinct(
  TreatmentID,
  .keep_all = TRUE
) 
```

### Cohort

A cohort label (combining pathology and region) was created from the processed diagnosis text.

```{r}
#| label: mastertable-5

# Slice Down Snapshot based on diagnosis availability

MasterTable5 <- MasterTable4 |> left_join(
  DiagFunc4 |> dplyr::select(
    TreatmentID,
    Term2
  )  |>
  summarize(
    Term3 = str_c(Term2, collapse = " "),
    .by = TreatmentID
  ),
  by = "TreatmentID"
)  |> left_join(
  DiagRegion1 |> dplyr::select(
    TreatmentID,
    RegionCat
  ),
  by = "TreatmentID"
) |> left_join(
  DiagPath1 |> dplyr::select(
    TreatmentID,
    PathCat
  ),
  by = "TreatmentID"
) |> tidyr::unite(
  "Cohort",
  c(RegionCat,PathCat),
  sep = "_",
  na.rm = FALSE,
  remove = FALSE
) |> left_join(
  DiagRegion1 |> filter(
    RegionCat == "Isolated"
    ) |> dplyr::select(
    TreatmentID,
    Region
  ),
  by = "TreatmentID"
) |> left_join(
  DiagPath1 |> filter(
    PathCat == "Isolated"
    ) |> dplyr::select(
    TreatmentID,
    Pathology
  ),
  by = "TreatmentID"
) |> mutate(
  Cohort1 = case_when(
    is.na(RegionCat) & is.na(PathCat) ~ NA_character_,
    RegionCat == "Multiple" & PathCat == "Multiple" ~ "Multiple",
    !is.na(Region) & is.na(Pathology) ~ Region,
    is.na(Region) & !is.na(Pathology) ~ Pathology,
    !is.na(Region) & !is.na(Pathology) ~ stringr::str_c(Region,Pathology, sep = "_")
  )
) |> mutate(
  Cohort2 = ifelse(n() < 30, "General", Cohort1),
  .by = Cohort1,
  Region2 = if_else(
    is.na(Region) & RegionCat == "Multiple", "Multiple", Region
  )
) |> dplyr::select(
  !c(
    Region,
    RegionCat
  )
) |> dplyr::rename(
  Region = "Region2"
) 



```

Establishing the breakdown of the sample by cohorts revealed that multiple pathologies across multiple regions of the foot-ankle was the most common presentation, followed by ankle_injury and multiple pathologies affecting the ankle (Figure 1).

```{r}
#| label: fig-cohort
#| fig-cap: "Breakdown of sample by defined cohorts - combined pathology and region labels."

min_count <- 10

# Basic counts
  basic_counts1 <- MasterTable5 |>
    count(Cohort2, sort = TRUE) |>
    mutate(
      percentage = n / sum(n) * 100,
      cumulative_percentage = cumsum(percentage)
    )


 # Create visualization
  plot_data <- basic_counts1 |>
    filter(
      n >= min_count,
      !is.na(Cohort2)
      )  # Filter for readability
  
  cohort_plot <- ggplot(plot_data, aes(x = reorder(Cohort2, -n), y = n)) +
    geom_bar(stat = "identity", fill = "steelblue") +
    geom_text(aes(label = sprintf("%.1f%%", percentage)), 
              vjust = -0.5, size = 3) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(title = "Distribution of Clinical Cohorts",
         x = "Cohort",
         y = "Count")
  
  knitr::knit_print(cohort_plot)
```

### Bilateral Status

The bilateral status of each record in the registry snapshot was calculated by grouping by PatientID, establishing those records with \>1 record in the table, then calculating whether the bilateral record was;

-   Bilateral - a patient has multiple treatments in the registry and the treatments span left and right sides

-   Unilateral - the patient record appears in the dataset with one or more records, but they pertain to only one side

```{r}
#| label: bilateral-processing-1
#| eval: true


SnapshotBilat1 <- MasterTable5 |> group_by(
  PatientID
) |> summarise(
  TreatmentCount = n()
) |> filter(
  TreatmentCount > 1
)

SnapshotBilat2 <- MasterTable5 |> dplyr::select(
  TreatmentID,
  PatientID,
  CombID,
  TreatmentStatus,
  DateTreatmentRecordCreation
) |> filter(
  PatientID %in% SnapshotBilat1$PatientID
) |> dplyr::left_join(
  Snapshot |> select(
    TreatmentID,
    AffectedSide
  ),
  by = "TreatmentID"
)

 
SnapshotBilat3 <- distinct(
  SnapshotBilat2,
  PatientID,
  .keep_all = FALSE
) |> left_join(
  SnapshotBilat2 |> filter(
    AffectedSide == "Left"
  ) |> group_by(PatientID) |> slice_min(DateTreatmentRecordCreation) |> ungroup() |> dplyr::select(
    CombID,
    PatientID
  ),
  by = "PatientID"
) |> rename(
  "CombLeft" = CombID
) |> left_join(SnapshotBilat2 |> filter(
    AffectedSide == "Right"
  ) |> group_by(PatientID) |> slice_min(DateTreatmentRecordCreation) |> ungroup() |> dplyr::select(
    CombID,
    PatientID
  ),
  by = "PatientID"
) |> rename(
  "CombRight" = CombID
) |> filter(
  !if_any(c(CombLeft, CombRight), is.na)
) |> mutate(
  BilateralFlag = "Bilateral"
)


```

Marry back into the master table.

```{r}
#| label: mastertable-6


MasterTable6 <- MasterTable5 |> left_join(
  SnapshotBilat3 |> dplyr::select(
    PatientID,
    BilateralFlag
  ),
  by = "PatientID"
) |> mutate(
  Provider2 = case_when(
    Provider == "AW" ~ "A",
    Provider == "MS2" ~ "B",
    Provider == "MS1" ~ "C",
    Provider == "RM" ~ "D"
  ),
  BilateralStatus = if_else(
    is.na(BilateralFlag),
    "Unilateral",
    BilateralFlag
  )
) 

```

### RECORD \[7.1\] Codes and Algorithms

<!--# RECORD 7.1: A complete list of codes and algorithms used to classify exposures, outcomes, confounders, and effect modifiers should be provided. If these cannot be reported, an explanation should be provided -->



### RECORD \[7.1\] Codes and Algorithms

<!--# RECORD 7.1: A complete list of codes and algorithms used to classify exposures, outcomes, confounders, and effect modifiers should be provided. If these cannot be reported, an explanation should be provided -->

## RECORD \[9\] Bias

<!--# Describe any efforts to address potential sources of bias -->

For a discussion of biases in the context of the clinical registry utilised for this analysis, refer to [@scholes2023]. Specific to this analysis, the following considerations are noted below.

::: {#tbl-bias}
+-------------------+--------------------------------------------------------------------------------------------------------------+---------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Bias              | Definition                                                                                                   | Source                    | Mitigation                                                                                                                                                                                    |
+===================+==============================================================================================================+===========================+===============================================================================================================================================================================================+
| Selection         |                                                                                                              |                           |                                                                                                                                                                                               |
+-------------------+--------------------------------------------------------------------------------------------------------------+---------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Misclassification | Treatment record labelled into incorrect cohort.                              | [@Benchimol2015]          | Clinical text retrieved by two experienced reviewers and transferred to registry.                                                                                                             |
|                   |                                                                                                              |                           |                                                                                                                                                                                               |
|                   |                                                                                                              |                           | Code functions used to process text in a repeatable workflow.                                                                                                                                 |
+-------------------+--------------------------------------------------------------------------------------------------------------+---------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Immortal Time     | Individuals meet eligibility criteria that can only assessed after followup has started                      | [@nguyen2021]             | Patients are enrolled at first presentation to the registry for their condition - but this does not necessarily represent first presentation to the clinic.                                   |
+-------------------+--------------------------------------------------------------------------------------------------------------+---------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Missing Data      | The absence of a data value where a treatment record is eligible to have a data value collected              | [@carroll2020]            | Multiple imputation was used to impute missing values and model-based predictions of outcomes used                                                                                            |
+-------------------+--------------------------------------------------------------------------------------------------------------+---------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Prevalent User    | Follow-up starts after eligible individuals have started the treatment. The follow-up time is left-truncated | [@nguyen2021]             | Eligibility and enrollment is performed prior to treatment offering for any patient or new presentation. Records where definitive treatment occurred before registry enrolment were excluded. |
+-------------------+--------------------------------------------------------------------------------------------------------------+---------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Pseudoreplication | Analyse data while ignoring dependency between observations. Inadequate model specification.                 | [@davies2015; @lazic2010] | Because not all patients had multiple treatments, mixed effects models were poorly specified. A generalised linear model was utilised instead.                                                |
+-------------------+--------------------------------------------------------------------------------------------------------------+---------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Confounder        | A variable of interest and a target outcome simultaneously influenced by a third variable                   | [@tennant2020]            | PCS-SF models incorporated adjustment for confounders                                                                                                                                         |
+-------------------+--------------------------------------------------------------------------------------------------------------+---------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Biases in an analysis of an observational cohort retrieved from a clinical registry
:::

## RECORD \[10\] Study size

<!--# Explain how the study size was arrived at -->

Sample size was derived based on the available records from the Registry at the time of analysis.

## RECORD \[11\] Quantitative variables

<!--# Explain how quantitative variables were handled in the analyses. If applicable, describe which groupings were chosen and why -->

No categorisation of quantitative variables was undertaken in this analysis.

## RECORD \[12\] Statistical methods

<!--# (a) Describe all statistical methods, including those used to control for confounding (b) Describe any methods used to examine subgroups and interactions (c) Explain how missing data were addressed (d) Cohort study—If applicable, explain how loss to follow-up was addressed Case-control study—If applicable, explain how matching of cases and controls was addressed Cross-sectional study—If applicable, describe analytical methods taking account of sampling strategy (e) Describe any sensitivity analyses -->

### Descriptives

<!--# check methods in gtsummary for univariate comparisons -->

### Regression preparation

Set up input table for statistical analysis with only variables required for models.

The *ggdag* package was used to create and visualise directed acyclic graphs (in conjunction with *ggplot2*), with minimal adjustment sets to ensure correct specification of models to estimate the effect of Group on outcome variables.







## RECORD \[14\] Patient Characteristics

<!--# (a) Give characteristics of study participants (eg demographic, clinical, social) and information on exposures and potential confounders(b) Indicate number of participants with missing data for each variable of interest (c) Cohort study—Summarise follow-up time (eg, average and total amount) -->

Summarising the sample by anatomical region showed the ankle to be most common presentation, followed by multiple regions.

```{r}
#| label: fig-cohort-breakdown
#| fig-cap: "Breakdown of sample by diagnostic group (region) labels and presence of arthritis."

min_count <- 10

# Basic counts
  basic_counts2 <- MasterAnalysis1 |> 
    count(Region,Arthritis, sort = TRUE) |>
    mutate(
      percentage = n / sum(n) * 100,
      cumulative_percentage = cumsum(percentage)
    ) |> tidyr::unite(
      "RegionArthritis",
      Region:Arthritis,
      remove = FALSE
    )


 # Create visualization
  plot_data <- basic_counts2 |>
    filter(
      n >= min_count,
      !is.na(Region)
      )  # Filter for readability
  
  cohort_plot <- ggplot(plot_data, aes(x = reorder(RegionArthritis, -n), y = n)) +
    geom_bar(stat = "identity", fill = "steelblue") +
    geom_text(aes(label = sprintf("%.1f%%", percentage)), 
              vjust = -0.5, size = 3) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(
         x = "Region",
         y = "Count")
  
  knitr::knit_print(cohort_plot)
  
  
```

Patient characteristics for the sample are summarised.

```{r}
#| label: tbl-demographics
#| tbl-cap: "Summary of patient and treatment record characteristics for the analysed sample."



TblDemo <- gtsummary::tbl_summary(
  MasterTable6,
  include = c(
    AgeAtInitialExam,
    Sex2,
    Provider2,
    BilateralStatus,
    VR12_Physical_TotalScore_Preop,
    VR12_Mental_TotalScore_Preop,
    SRCQTotalScore,
    InjuryToPresentation,
    PCSSF_TotalScore_Preop,
    Region
  ),
label = list(
    Provider2 ~ "Provider",
    AgeAtInitialExam ~ "Age",
    InjuryToPresentation ~ "Onset to Presentation (Days)",
    BilateralStatus ~ "Bilateral",
    #Region ~ "Anatomical Region",
    Sex2 ~ "Female",
    VR12_Physical_TotalScore_Preop ~ "Physical Score",
    VR12_Mental_TotalScore_Preop ~ "Mental Score",
    SRCQTotalScore ~ "Comorbidity Score",
    PCSSF_TotalScore_Preop ~ "Pain Catastrophising"
    ),
    type = list(
    Sex2 ~ "dichotomous",
    BilateralStatus ~ "dichotomous"
    ),
    value = list(
      Sex2 ~ "Female",
      BilateralStatus ~ "Bilateral"
    ),
    statistic = list(
      all_continuous() ~ "{mean} ({sd})",
      all_categorical() ~ "{p}% ({n})"
      ),
    missing = "no"
) 

# |> gtsummary::add_n() |>
#   gtsummary::add_overall() |>
#   gtsummary::add_ci(statistic = list(all_categorical() ~ "{conf.low} - {conf.high}",
#                           all_continuous() ~ "{conf.low} - {conf.high}"),
#                           conf.level = 0.99,
#                           ) |>
#   gtsummary::add_stat_label(
#     location = "row"
#   )
  

knitr::knit_print(TblDemo)


```
